# trading/strategies/base_strategy.py

import abc
import logging
from typing import Any, Dict, List, Optional, TypedDict
from enum import Enum

# Import relevant data structures from your plugins.base
# These will be part of the data passed to the strategy's analyze method.
from plugins.base import OHLCVBar, Order, Position, Balance, InstrumentTradingDetails

logger = logging.getLogger(__name__)

# --- Signal Definition ---

class SignalAction(str, Enum): # Using str and Enum for better type hinting and potential string comparisons
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD" # Indicates no action or maintain current state
    CLOSE_POSITION = "CLOSE_POSITION" # Signal to close an existing position for a symbol
    # More actions can be added, e.g., INCREASE_POSITION, DECREASE_POSITION, CANCEL_ORDER

class Signal(TypedDict, total=False):
    """
    Represents a trading signal generated by a strategy.
    The 'action' field is mandatory. Other fields depend on the action.
    """
    action: SignalAction          # The core action (BUY, SELL, HOLD, CLOSE_POSITION)
    symbol: str                   # The trading symbol this signal applies to (e.g., BTC/USDT)

    # Fields primarily for BUY/SELL signals
    order_type: Optional[str]     # e.g., 'market', 'limit'. Strategy might decide or leave to bot executor.
    amount: Optional[float]       # Desired quantity to trade (in base currency).
                                  # Can be absolute or a fraction of available capital/position size.
    price: Optional[float]        # For 'limit' orders: the desired price.

    # Risk management parameters suggested by the strategy
    stop_loss_price: Optional[float]
    take_profit_price: Optional[float]

    # For modifying existing state
    position_to_modify: Optional[Position] # Reference to an existing position for actions like CLOSE_POSITION
    order_to_cancel: Optional[Order]     # Reference to an existing order to be cancelled

    # Additional metadata
    confidence: Optional[float]   # Strategy's confidence in this signal (e.g., 0.0 to 1.0)
    comment: Optional[str]        # Any notes or reasons from the strategy
    strategy_name: Optional[str]  # Name of the strategy generating the signal


# --- Market Data for Strategy Analysis ---

class StrategyMarketData(TypedDict):
    """
    A structured dictionary to pass market information to a strategy's analyze method.
    """
    symbol: str
    timeframe: str
    ohlcv_bars: List[OHLCVBar]                     # Historical OHLCV data
    latest_bar: Optional[OHLCVBar]                 # Most recent complete bar
    current_tick: Optional[Dict[str, Any]]         # Optional: Latest tick data (if strategy uses it)
    instrument_details: InstrumentTradingDetails   # Details like precision, limits


# --- Abstract Base Class for Trading Strategies ---

class TradingStrategyBase(abc.ABC):
    """
    Abstract base class for all trading strategies.
    Concrete strategies must implement the `analyze` method.
    """
    strategy_key: str = "base_strategy" # Unique identifier for the strategy type
    strategy_name: str = "Base Trading Strategy" # User-friendly name
    strategy_description: str = "A base class for trading strategies."

    def __init__(self, params: Optional[Dict[str, Any]] = None):
        """
        Initializes the trading strategy.

        Args:
            params (Optional[Dict[str, Any]]): Strategy-specific parameters
                                                (e.g., moving average periods, RSI thresholds).
                                                These are typically loaded from the bot's configuration.
        """
        self.params: Dict[str, Any] = params if params is not None else {}
        self.current_symbol: Optional[str] = None # Can be set by the bot runner
        self.current_timeframe: Optional[str] = None # Can be set by the bot runner

        logger.info(f"Strategy '{self.strategy_name}' (Key: {self.strategy_key}) initialized with params: {self.params}")

    @abc.abstractmethod
    async def analyze(
        self,
        market_data: StrategyMarketData,
        account_balance: Dict[str, Balance], # Overall account balance
        open_positions: List[Position],      # List of currently open positions for the account
        open_orders: List[Order]             # List of currently open orders for the account
    ) -> List[Signal]:
        """
        Analyzes market data, account status, and open positions/orders to generate trading signals.
        This is the core logic of the strategy.

        Args:
            market_data (StrategyMarketData): Contains OHLCV, latest bar/tick, and instrument details
                                             for the symbol(s) the strategy is monitoring.
            account_balance (Dict[str, Balance]): The current account balance information.
            open_positions (List[Position]): A list of currently open positions.
                                             The strategy might use this to decide on closing,
                                             adjusting, or avoiding new conflicting positions.
            open_orders (List[Order]): A list of currently open (active) orders.
                                        The strategy might use this to avoid placing duplicate orders
                                        or to manage existing ones (though cancellation might be a separate signal).

        Returns:
            List[Signal]: A list of trading signals. Can be empty if no action is warranted.
                          A strategy might emit multiple signals (e.g., close one position, open another).
        """
        pass

    def get_details(self) -> Dict[str, Any]:
        """
        Returns a dictionary with the strategy's key, name, description, and current parameters.
        Useful for UI or logging.
        """
        return {
            "strategy_key": self.strategy_key,
            "strategy_name": self.strategy_name,
            "strategy_description": self.strategy_description,
            "current_parameters": self.params,
        }

    # Optional: Helper methods that might be common across strategies
    # For example, calculating indicators, risk management, order sizing.
    # These can be added here or in separate utility modules.
    # async def calculate_sma(self, ohlcv_bars: List[OHLCVBar], period: int) -> Optional[float]:
    #     # ... implementation ...
    #     pass